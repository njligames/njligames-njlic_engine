//! \mainpage Easylogger
//!
//! easylogger - Simple "good enough" C++ logging framework
//!
//! Copyright (C) 2010 Sean Middleditch <sean@middleditch.us>
//!
//! Easylogger is free software; you can redistribute it and/or modify
//! it under the terms of the MIT license. See LICENSE for details.

#if !defined(EASYLOGGER_H)
#define EASYLOGGER_H

#include <iostream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <map>

namespace easylogger
{
    class Logger;
}

//! Main namespace containing all Easylogger functionality
namespace easylogger
{
    //! Log levels
    enum LogLevel {
        LEVEL_TRACE,    //!< Trace-level messages (0)
        LEVEL_DEBUG,    //!< Debug-level messages (1)
        LEVEL_INFO,        //!< Info-level messages (2)
        LEVEL_WARNING,    //!< Warning-level messages (3)
        LEVEL_ERROR,    //!< Error-level message (4)
        LEVEL_FATAL        //!< Fatal-level message (5)
    };
    
    //! Private namespace
    //! \internal
    namespace _private {
        
        //! Sink for log message streaming
        //!
        //! \internal
        class LogSink {
        public:
            //! Construct a new sink
            //!
            //! \param logger Logger instance to log to.
            //! \param level Level of messages generated by sink.
            //! \param file File name of log location.
            //! \param line Line of file of log location.
            //! \param func Name of function at log location.
            LogSink(Logger* logger, LogLevel level, const char* file,
                    unsigned int line, const char* func) : _logger(logger),
            _level(level), _file(file), _line(line), _func(func) {}
            
            //! Copy constructor
            //!
            //! \param sink Source LogSink.
            LogSink(const LogSink& sink) : _logger(sink._logger),
            _level(sink._level), _file(sink._file), _line(sink._line),
            _func(sink._func) {}
            
            //! Get the internal stream of the sink
            //!
            //! \returns internal std::ostream
            ::std::ostream& Stream() { return _os; }
            
            ~LogSink();
            
            //! Get the minimum log level of the Logger
            //!
            //! \returns Minimum log level
            LogLevel Level() const { return _level; }
            
        private:
            ::std::ostringstream _os;
            
            Logger* _logger;
            
            LogLevel _level;
            
            const char* _file;
            
            unsigned int _line;
            
            const char* _func;
        };
        
    } // namespace _private
    
    //! Logger system core class
    class Logger {
    private:
        Logger();
        Logger(const Logger &rhs);
    public:
        //! Construct a new Logger
        //!
        //! \param name Name of logger used in log messages.
        Logger(const std::string& name) :
        _name(name),
        _parent(0),
        _level(LEVEL_INFO),
        _format("[%F:%C %P] %N %L: %S"),
        _timeFormat("%c"){
            AddStream("default", ::std::cout);
        }
        
        //! Construct a new Logger with a parent
        //!
        //! \param name Name of logger used in log messages.
        //! \param parent Parent Logger all messages are forwarded to.
        Logger(const std::string& name, Logger& parent) :
        _name(name),
        _parent(&parent),
        _level(LEVEL_INFO),
        _format("[%F:%C %P] %N %L: %S"),
        _timeFormat("%c"){
            AddStream("default", ::std::cout);
        }
        
        ~Logger() {Flush();}
        
        //! Get the name of the Logger
        //!
        //! \returns Logger's name
        const ::std::string& Name() const { return _name; }
        
        //! Get the minimum log level of the Logger
        //!
        //! \returns Minimum log level
        LogLevel Level() const { return _level; }
        
        //! Set the minimum log level of the Logger
        //!
        //! \returns New minimum log level
        LogLevel Level(LogLevel level) {
            return _level = level;
        }
        
        //! Checks if this Logger or any ancestor accepts a given log level
        //!
        //! Each Logger will only log messages of a particular level or
        //! higher.  This method will check if this Logger instance or
        //! any of its parents are willing to log a message of a given
        //! log level.
        //!
        //! \param level Log level to check for.
        //! \returns true if any ancestor will accept log level
        bool IsLevel(LogLevel level) const {
            return _level <= level;
        }
        
        //! Create a new log sink
        //!
        //! Does the actual work of writing log message.
        //!
        //! \param level Level of log message.
        //! \param file Name of file at point of log.
        //! \param line Line of file at point of log.
        //! \param func Name of function at point of log.
        _private::LogSink Log(LogLevel level, const char* file,
                              unsigned int line, const char* func) {
            return _private::LogSink(this, level, file, line, func);
        }
        
        bool AddStream(const ::std::string &name, ::std::ostream& stream)
        {
            return _streamMap.insert(StreamPair(name, &stream)).second;
        }
        
        bool RemoveStream(const ::std::string &name)
        {
            return (_streamMap.erase(_streamMap.find(name)) != _streamMap.end());
        }
        
        ::std::ostream* GetStream(const std::string &name)
        {
            auto search = _streamMap.find(name);
            if(search != _streamMap.end())
            {
                return (search->second != 0)?search->second:_parent->GetStream(name);
            }
            return 0;
        }
        
        //! Get the log format string
        //!
        //! \returns Log format string.
        const ::std::string& Format() const { return _format; }
        
        //! Get the log time format string
        //!
        //! \returns Log time format string.
        const ::std::string& TimeFormat() const { return _timeFormat; }
        
        //! Set the log format string
        //!
        //! \param format New log format string.
        //! \returns Log format string.
        const ::std::string& Format(const ::std::string& format) {
            return _format = format;
        }
        
        //! Set the log format string
        //!
        //! \param format New log time format string.
        //! \returns Log time format string.
        const ::std::string& TimeFormat(const ::std::string& format) {
            return _timeFormat = format;
        }
        
        //! Flushes underlying output stream
        void Flush() {
            for(StreamMap::iterator i = _streamMap.begin(); i != _streamMap.end(); i++)
            {
                if(i->second)
                    i->second->flush();
            }
        }
        
    private:
        
        std::string Now( const char* format = "%c" )
        {
            std::time_t t = std::time(0) ;
            char cstr[128] ;
            std::strftime( cstr, sizeof(cstr), format, std::localtime(&t) ) ;
            return cstr ;
        }
        
        //! Write log to stream
        //!
        //! Does the actual work of writing log message.
        //!
        //! \param level Level of log message.
        //! \param logger Original Logger target of message.
        //! \param file Name of file at point of log.
        //! \param line Line of file at point of log.
        //! \param func Name of function at point of log.
        //! \param message The log message.
        void WriteLog(LogLevel level, Logger* logger, const char* file,
                      unsigned int line, const char* func, const char* message) {
            if(_streamMap.size() > 0)
            {
                for(StreamMap::iterator i = _streamMap.begin();
                    i != _streamMap.end();
                    ++i)
                {
                    ::std::ostream *stream = GetStream(i->first);
                    this->WriteLog(level, logger, file, line, func, message, stream);
                }
            }
        }
        
        //! Write log to stream
        //!
        //! Does the actual work of writing log message.
        //!
        //! \param level Level of log message.
        //! \param logger Original Logger target of message.
        //! \param file Name of file at point of log.
        //! \param line Line of file at point of log.
        //! \param func Name of function at point of log.
        //! \param message The log message.
        //! \param stream The stream to write to.
        void WriteLog(LogLevel level, Logger* logger, const char* file,
                      unsigned int line, const char* func, const char* message, ::std::ostream *stream){
            
            if (stream != 0) {
                const char* cptr = _format.c_str();
                while (*cptr != 0) {
                    if (*cptr == '%') {
                        switch (*++cptr) {
                                // % at end of stream
                            case 0:
                                *stream << '%' << ::std::endl;
                                return;
                                // %% - literal escape
                            case '%':
                                *stream << '%';
                                break;
                                // %F - file name
                            case 'F':
                                *stream << "file://" << file;
                                break;
                                // %C - line counter
                            case 'C':
                                if (line != 0) {
                                    *stream << line;
                                } else {
                                    *stream << '?';
                                }
                                break;
                                // %P - function name
                            case 'P':
                                *stream << func;
                                break;
                                // %N - logger name
                            case 'N':
                                *stream << logger->Name();
                                break;
                                // %L - log level
                            case 'L':
                                switch (level) {
                                    case LEVEL_TRACE: *stream << "TRACE"; break;
                                    case LEVEL_DEBUG: *stream << "DEBUG"; break;
                                    case LEVEL_INFO: *stream << "INFO"; break;
                                    case LEVEL_WARNING: *stream << "WARNING"; break;
                                    case LEVEL_ERROR: *stream << "ERROR"; break;
                                    case LEVEL_FATAL: *stream << "FATAL"; break;
                                    default: *stream << "UNKNOWN"; break;
                                }
                                break;
                                // %M - message
                            case 'S':
                                *stream << message;
                                break;
                                // %T - time
                            case 'T':
                                *stream << Now(_timeFormat.c_str());
                                break;
                        }
                    } else {
                        *stream << *cptr;
                    }
                    
                    ++cptr;
                }
                *stream << ::std::endl;
            }
        }
        
        
        
        ::std::string _name;
        
        Logger* _parent;
        
        LogLevel _level;
        
        typedef ::std::map<std::string, ::std::ostream*> StreamMap;
        typedef ::std::pair<std::string, std::ostream*> StreamPair;
        
        StreamMap _streamMap;
        
        ::std::string _format;
        
        ::std::string _timeFormat="%c";
        
        friend class _private::LogSink;
    };
    
#if !defined(EASYLOGGER_LOGSINK_H)
#define EASYLOGGER_LOGSINK_H
//        namespace _private {
//            _private::LogSink::~LogSink() {
//                _logger->WriteLog(Level(), _logger, _file, _line, _func,
//                                  _os.str().c_str());
//            }
//        }
#endif
    
} // namespace easylogger

//! Stream operator for LogSink
template <typename T>
::easylogger::_private::LogSink& operator<<(::easylogger::_private::LogSink& sink, const T& val) {
    sink.Stream() << val;
    return sink;
}

#undef DEBUG_LOG_FUNCTIONS
//#define DEBUG_LOG_FUNCTIONS

//! General logging helper
//!
//! \internal
//! \param logger Logger to log to.
//! \param level Level to log at
//! \param message Stream message.
#if !defined(DEBUG_LOG_FUNCTIONS)
#define _EASY_LOG(logger, level, message) do{ \
if ((logger).IsLevel((level))) { \
do { \
::easylogger::_private::LogSink _easy_sink((logger).Log(level, __FILE__, __LINE__, __PRETTY_FUNCTION__)); \
_easy_sink << message; \
} while(0); \
if ((level) == ::easylogger::LEVEL_FATAL) { \
(logger).Flush(); \
std::abort(); \
} \
} \
}while(0)
#else
static void _EASY_LOG(easylogger:: Logger &logger, const easylogger::LogLevel level, const std::string &message)
{
    do
    {
        if ((logger).IsLevel((level)))
        {
            do
            {
                ::easylogger::_private::LogSink _easy_sink((logger).Log(level, __FILE__, __LINE__, __FUNCTION__));
                _easy_sink << message;
            } while(0);
            if ((level) == ::easylogger::LEVEL_FATAL)
            {
                (logger).Flush();
                std::abort();
            }
        }
    } while(0);
}
#endif

#if !defined(DEBUG_LOG_FUNCTIONS)
#define LOG_TRACE(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_TRACE, message)
#define LOG_DEBUG(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_DEBUG, message)
#define LOG_INFO(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_INFO, message)
#define LOG_WARNING(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_WARNING, message)
#define LOG_ERROR(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_ERROR, message)
#define LOG_FATAL(logger, message) _EASY_LOG((logger), ::easylogger::LEVEL_FATAL, message)
#else
void LOG_TRACE(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_TRACE, message);
}

void LOG_DEBUG(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_DEBUG, message);
}

void LOG_INFO(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_INFO, message);
}

void LOG_WARNING(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_WARNING, message);
}

void LOG_ERROR(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_ERROR, message);
}

void LOG_FATAL(easylogger:: Logger &logger, const std::string &message)
{
    _EASY_LOG((logger), ::easylogger::LEVEL_FATAL, message);
}
#endif

//#if !defined(NDEBUG)
//# define ASSERT(logger, expr, msg) do{ \
//        if (!(expr)) { \
//            _EASY_LOG((logger), ::easylogger::LEVEL_FATAL, "ASSERTION FAILED: " #expr ": " msg); \
//        } \
//    }while(0)
//#else
//# define ASSERT(logger, expr, msg) do{ }while(0)
//#endif
//
//#define ASSERT_NOTNULL(logger, expr, msg) ASSERT((logger), (expr) != NULL, msg)
//#define ASSERT_EQ(logger, lhs, rhs, msg) ASSERT((logger), (lhs) == (rhs), msg)
//#define ASSERT_NE(logger, lhs, rhs, msg) ASSERT((logger), (lhs) != (rhs), msg)
//#define ASSERT_TRUE(logger, expr, msg) ASSERT((logger), (expr) == true, msg)
//#define ASSERT_FALSE(logger, expr, msg) ASSERT((logger), (expr) == false, msg)

//namespace easylogger
//{
//    _private::LogSink::~LogSink() {
//        _logger->WriteLog(Level(), _logger, _file, _line, _func,
//                          _os.str().c_str());
//    }
//}
#endif
